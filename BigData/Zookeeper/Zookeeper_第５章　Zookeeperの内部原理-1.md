# 分散型協調サービスフレームワーク -- Zookeeper-5

## 第５章　Zookeeperの内部原理-1

### 第１節　Leaderの選挙機構

#### 選挙機構

- 半数以上の機器が稼働していれば、クラスタは利用可能です。従って、ZooKeeperは奇数台のサーバーで設定するのが適している。
- ZooKeeperの配置ファイルにはMasterやSlaveを指定する項目はないが、実際にはLeaderとFollowerという役割がある。ZooKeeperは内部の選挙機構によってLeader節点が選ばれ、他の節点はFollowerとなる。

#### 選挙流れ

　　選挙過程が大体２種の場合が分けられる。

**初めて起動**

　　仮に、IDが1から5までの5台のサーバーで構成されたZooKeeperクラスターがあり、これらのサーバーは全て最新の起動であり、過去のデータは持ってないと仮定する。![image-20231023163347227](D:\OneDrive\picture\Typora\image-20231023163347227.png)

1. Server1が起動し、この時点ではServerのID最大の自分に投票してあげる。従って、Server1から発信されるメッセージには応答のサーバーがない。そのため、Server1の選挙の状態は常にLOOKING（リーダーの選出を待機中）の状態です。
2. Server2が起動し、同じに自分に投票してあげる。後で、最初に起動したServer1と投票結果を通信し、両者がお互いに選挙結果を交換することが行う。最初起動する場合はどちらも過去のデータがないので、ServerのID（myid）が大きいServer2が２票で勝利する。ただし、半数以上のサーバーが同意しなかったため（この例では半数以上が3台）、Server1と2は引き続きLOOKINGの状態を維持する。
3. Server3が起動する。前述の理論に基づいて半分以上台数の規則が満たし、Server3はServer1、2、3の中で最大のIDを持つため、3票を取得したServer3が順調にLeaderとなる。
4. Server4が起動します。前述の分析に基づいて、理論的にはServer4が最大のIDを持つはずですが、既にServer3を半数以上の投票で選出していたため、Server4はFollowerとして運行することになる。
5. Server5が起動する。Server4と同様にFollower役を担当する。

**初めて起動ではない**

　　半数以上のサーバーが稼働している状態を前提として、最大のトランザクションID（cZxid）を持つサーバーをLeaderに選挙してある。各サーバーの保存したcZxidが同じなら、myidが大きいのサーバーがLeaderを選出される。もしLeaderサーバーが故障などの原因で運行しなくなった場合、さっき言った規則に沿って改めて選挙を行う。Follower故障に対して残るサーバーが稼働し続き、特別な変更がない。故障サーバーが正常に復旧し、Leaderから最新のバックアップを取得して他のサーバーと一致するになる。

#### 選挙内容

　　実際の選挙流れが上記よりもっと複雑であり、ここで選挙の具体的な細部の部分について紹介している。

**サーバー状態**

　　不同な任務を処理できるため、複数のサーバー状態を設定された。公式パッケージ中に**org.apache.zookeeper.server.quorum.QuorumPeer.ServerState**クラスがその状態を設定されてある。

- **LOOKING**：選挙を進行してる過程でサーバーの状態です。
- **LEADING**：当のサーバーがLeader役を担当する。
- **FOLLOWING**：当のサーバーがFollower役を担当する。
- **OBSERVING**：選挙を参加しないFollowerを理解でき、普通の請求を処理するだけ、特別にObserver役を設定する必要です。

![image-20231101072451012](D:\OneDrive\picture\Typora\image-20231101072451012.png)

**消息隊列**

　　QuorumCnxManagerクラスでは、受信した消息、送信待ちの消息などを保存するために多くの隊列が管理されている。多数の隊列がServerIDに基づいて組み分けされる。

- **recvQueue**： 消息受信の隊列、受信したすべての消息がここに保存される。
- **queueSendMap**： 待ち消息の隊列、送信待ちの消息の集合に保存され、Mapとして定義されている。ServerIDに基づいて組み分け、各ServerIDには隊列が関連付けられ、消息の送受信が互いに影響しないようになっている。
- **senderWorkMap**： 送信者の集合。各senderWork送信者は、ZooKeeperとのリモート接続を担当し、消息の送信を担当する。内部ではServerIDに基づいて組み分けされている？？？
- **lastMessageSent**： 最後に送信された消息。この集合では、毎ServerIDの最新の送信消息が保持される。

![image-20231102112352368](D:\OneDrive\picture\Typora\image-20231102112352368.png)

**キー変数**

　　毎回Leaderを選挙する過程の中に、基本変数の変わりに及んである。選挙段階に需要の変数が**apache.zookeeper.server.quorum.Vote**クラスに定義される。

- **id**：当のサービスのid番号、配置ファイルにmyidで表示し、も上記のServerIDです。
- **zxid**：トランザクション請求の唯一のID、ID番号が大きいほどデータも最近になる。
- **electionEpoch**：現在で何回投票を記録する。新しい投票に入って１を加えることがある。
- **peerEpoch**：毎回の投票を完了して新たな値を作成してあり、今回の投票を特に表示する。zxidの高さの8位と同じ、低さの8位が今回の投票内に何回トランザクション請求を処理した回数です。

![image-20231102111050057](D:\OneDrive\picture\Typora\image-20231102111050057.png)

**選挙初期化**

　　起動直後の状態であり、各サービスは自身をLeaderとして自動的に選出し、投票を行う。投票の過程は選挙で必要な基本的な要素が含まれる。例えば、myidが1で、ZXIDが0の場合、(1,0)と表記する。自身をLeaderとして優先的に選出するため、server1の投票は(1,0)で、server2の投票は(2,0)となり、後ろのサービスが同様の方式にする。

**接続確立**

　　ZooKeeperクラスタ内にペア毎に接続を確立する必要がある。QuorumCnxManagerクラスは、Leader選出の通信ポートを監聴するためにServerSokectを作成し、請求を受信した際にはreceiveConnection関数を呼び出して処理する。ただし、重複したTCP接続の作成を避けるためServerIDが大きいサービスからServerIDが小さいへの接続を許可する。接続が確立されると、ServerIDに基づいて送信者のsenderWorkerと受信者RecvWorker実体（instance）が作成される。

![image-20231107080006835](D:\OneDrive\picture\Typora\image-20231107080006835.png)

**受信と送信**

　　受信者は消息を受信すると、それをrecvQueue隊列に保存する。他の投票情報を取得できない場合は、現在のサービスが他のサービスとの接続を維持しているか確認し、LOOKING状態です。接続が断続的又は存在しない場合は、再度接続を確立する。

　　消息の送信は簡単で、各ServerIDには独立したSendWorkerが存在しているため、queueSendMapから送信するデータを取得し続けるだけです。送信が完了すると、送信したばかりの消息がlastMessageSentに保存される。ただし、注意すべき点は、待ちの送信消息の隊列が空であることがわかった場合、lastMessageSentから直前に送信された消息を取得し、再度消息として送信することです。ZooKeeper自体が重複消息に対して処理機能を持っているため、消息が何か故障で失うより消息を再送信して正しく処理できることが重要です。

**投票処理**

　　初期投票を送信した後、受け取ったサービスが投票情報の処理が開始する。

- まず、受け取った外部投票の選挙回数（electionEpoch）が現在の投票の選挙回数（Logicalclock）よりが大きいかどうかを判断する。もし外部投票の選挙回数が大きい場合、現在のサービスのLogicalclockを更新し、受信者の全ての投票をクリアする。そして、再び投票と外部投票を比較して、自分自身の投票を変更する必要があるかどうかを決定する。
- 外部投票の選挙回数が現在のサーバーの選挙回数よりも少ない場合、その投票情報は無視される。
- 外部投票と現在のサービスの選挙回数が同じ場合、投票の比較操作が必要になる。

**選挙比較**

　　選票比較は、FastLeaderElectionクラスのtotalOrderPredicate`メソッドで実装されている。現在のサービスの選票情報が変更される必要があるかどうかを決定する。そのため、選挙回数、ZXID、SIDに基づいて比較が行われます：

- 選挙回数が同じであれば、ZXIDを比較する。もし外部投票のZXIDが大きければ、自身のサービスの選票情報を変更する必要がある。
- ZXIDが同一であれば、SIDを比較する。外部投票のSIDが大きければ、自身のサービスの選票情報を変更する必要がある。

　　この規則に従って、まず、両方の投票が第一の選挙であるため、zxidは0です。次にmyidを比較し、server1のmyidは1で投票結果が(1,2)、server2のmyidは2で投票結果が(2,2)です。自身のmyidより大きいため、server2が勝ってあるべき、ServerIDに基づいての投票結果が自分の対応の隊列に保存される。その後、server1の投票を(2,0)に更新し、次に送信する際は新しい投票情報を送る。

　　その更新する後で再送信の過程が複数のLeaderを選出されたのが出現しないことが保証し、最後のキー票が一つのサーパスに投げるだけ。

**票数の統計**

　　投票が行われる度に、全ての投票が集計され、過半数のサービスが同じ投票情報を受け入れたかどうかが判断される。現在のserver1とserver2にとっては、これら2つのサービスの投票が同じでなければ、選挙プロセスが完了したとは言えない。奇数のサービスがある場合は、(サービス数 + 1) / 2 のサーバーが同じ投票を受け入れれば良いです。上記の流れを経た後、server1が投票を比較し、(2,0)の更新した投票情報を確定すれば、選挙は完了する。

**同期状態**

　　一旦選挙が完了したら、選挙の結果に従って全てのサーパスが自身の状態を更新すると進行し、LOOKINGからLeader又はFollowerに変わる。

**故障**

　　通常、Zookeeperクラスタを起動した後、Leaderはクラスタ内で常にLeaderとして運行する。クラスタ内のFollowerが故障したり、新しいサーバーがクラスタに参加した場合でも、Leaderに影響を与えない。ただし、一旦Leaderが応答できなくなったり故障である場合、Zookeeperクラスタは外部サービスを提供できなくなり、新しいLeaderの選挙が行われる。この選挙流れは、クラスタを初期化して起動する際の選挙と大体同じですが、違い点は各サービスが自身の実行状態から選挙状態に切り替わるんです。

#### **FastLeaderElectionアルゴリズム** 

　　FastLeaderElectionはZookeeper選挙機構の核心アルゴリズム、本質は上記の内容と同じ、ここで全体の流れをざっと説明してくる。

**自動選挙回数の増加**

　　FastLeaderElectionの実装では、logicalclock属性があり、現在の選挙回数を識別する。ZooKeeperは、各選挙が同じ選挙の周期内で行われる必要があると要求している。したがって、各選挙の前にlogicalclockを自動的に増加させ、現在の選挙周期に到達する。

**選挙票の初期化**

　　初期化段階では、各サービスは自身をリーダーとして推薦し、自身を主とした選挙票を初期化する。

**初期化された選挙票の送信**

　　選挙票を初期化したら、自身の選挙票情報をsendQueue隊列に保存し、各ServerIDに対応するworkerSenderがそれを送信する。

**外部からの投票情報の受信**

　　初期化段階では、自身の選挙票情報を送信するだけでなく、他のサービスからの選挙票情報も受信する。これらの情報はrecvQueue隊列に保存され、他の選挙票情報を取得できない場合は、現在のサービスが他のサービスと接続を維持しているである。接続が切断されたか、接続がない場合、再度接続を確立する。重複した接続の作成を防ぐため、毎回の接続はSIDを付いて行う。

**選挙回数の判断**

　　最初に受信した外部投票の選挙回数が現在の選挙回数より大きいかどうかを判断する。

**選挙票の比較**

　　選挙票の比較は、選挙アルゴリズムの中心的な論理です。具体的な説明は上記を参考できる。

**選挙票情報の変更と再度送信**

選挙票の比較後、自身の選挙票情報を変更する必要がある場合、自身の選挙票情報を変更し、再度新しい選挙票情報を送信します。

**選挙票の統計とアーカイブ**

　　各サービスは、送信や受信の過程で、更新した選挙票情報又は無視する選挙かどうかに関係なく、各選挙票の情報をrecvSetにSIDで選挙票情報を区別して保存し、統計を行う。半数以上の投票を得たサービスが確認したら、選挙票情報の再送信を停止し、選挙を終了する。それ以外の場合は、上記の送信と受信の選挙票流れを繰り返する。

**サービス状態を変更**

　　最終的なLeaderサービスが統計されると、各サービスの状態を変更し始める。
