# 分散型協調サービスフレームワーク -- Zookeeper-5

## 第５章　Zookeeperの内部原理-2

### 第２節　ZAB協議

　　ZAB（Zookeeper Atomic Broadcast）は崩壊の回復を支持するの原子放送協議です。別の言い方は、ZooKeeperクラスタ内の各サーバー間のデータ整合性を維持するため設計されたの稼働規則という解釈が理解しやすいと思う。ZAB協議が各サーバー間に稼働の流れを説明でき、主にLeader/Follower主従関係の架構を通じてクラスタ全体の整合性を実現してくる。

#### ZAB協議流れ

![image-20231027144653558](D:\OneDrive\picture\Typora\image-20231027144653558.png)

　　ZAB協議は、各Leaderが3つの段階（発見、同期、放送）を経る必要があり、その前に必ず全局の唯一のLeaderを選出する。

**発見（Discovery）**

　　ZooKeeperクラスターは必ず1つのLeaderプロセスを選出する必要がある。この段階では、Followersと当の選挙で選出された準Leaderが通信し、Followersが最近受信したトランザクション提案（Proposal）を同期する。主な目的は、現在の大多数の節点が受信した最新の提案を発見し、準Leaderが新しいepoch（今回選挙標識）を生成し、Followersがそれを受け入れてそれぞれのacceptedEpochを更新することです。

**同期（Synchronization）**

　　Leaderは、自身のデータをFollowerと同期させる責任を持ち、複数のバックアップを保存する必要がある。この段階では、Leaderが前段階で取得した最新の提案履歴を利用して、クラスタ内の全てのバックアップを同期する。半数以上の節点（quorum）が完了すると、準Leaderが本当のLeaderになる。Followerは、自分のlastZxidよりも大きなzxidを持つ提案のみを受け入れる。Followerの隊列の未処理の請求を完了した後、受信の情報を本地のログに書き込む。

**放送（Broadcast）**

　　ここから各サーバーの前期準備が終わり、外部の請求を受信し始める。

　　先ず、トランザクション請求（write request）の処理について、Leaderが唯一の担当者として新しいトランザクション提案を全てのFollowerに通知して放送する責任がある。どの節点であってもトランザクション請求を受信したら、請求をLeaderに転送して統一に処理する。Leaderが単一の主プロセスで請求の内容に応じてデータを変更操作を順次行う。サーバーのデータの状態が変更されると、対応のバックアップを作成し、その後、バックアップを他の節点に分配し、各サーバーが最新の変更内容を保証できてくる。ここでも半分以上のFollowerの同期を完成したのが満足です。その過程でLeader以外の役（Follower/Observer）がLeaderの購読者（Subscriber）みたいLeaderからバックアップを受け取る。

　　次に、普通の読み込み請求（read request）について、請求を受信した節点が自身の検査結果を直接返し、Leaderに報告するなど請求が必要ない。

#### ZAB協議内容

　　ZAB協議は基本的に二つの模式が分け：回復模式や放送模式。

**回復模式**

　　クラスタ全体の起動中や、Leaderサーバーが通信の切断、崩潰、再起動などの異常を起こした場合、クラスタが回復模式に入る。具体の内容は、Leaderが選出されたから外部の請求を受信するまでの準備、どのようにデータを同期して各Subscriberが一致性を保証することが解釈してある。

- Leaderは各Subscriberに対して順序を保証するまま提案を送信するために、各subscriberに隊列を用意する。
- Leaderは各Subscriberが同期していないトランザクションをProposalとして包装してくれる。
- LeaderはこれらのProposalを個別にSubscriberに送信し、Ackのフィードバックを受信するとSubscriberにCommitメッセージを発出してProposalをコミットさせる。その時使用可能なSubscriberリストに追加する。ACKがない場合、又はACKが返信されたがLeaderが受信しなかった場合、Leaderはそれを対応するリストに追加しない。
- SubscriberはCommitメッセージを受信し、本地のデータを更新する。

　　クラスが起動中であるか、又はLeaderが半数以上のホストとの接続を失った場合、クラスタは回復模式に入る。データを復旧する過程には2つの原則がある。

- 処理済みのメッセージは失われてはならない:

  　　Leaderは半数以上のSubscriberからACKを受信すると、各SubscriberにCOMMITメッセージを発送し、書き込み操作の実行を承認する。

  　　ただし、全SubscriberがCOMMITメッセージを受信する前にLeaderが故障した場合、結果として次のような問題が発生する：一部のSubscriberはすでにそのトランザクションを実行しており、一部のSubscriberはまだCOMMITメッセージを受信してない。従って、新しいLeaderが選出されると、クラスタが回復模式を経て部分の実行しないトランザクションがコミット操作を完成することを保証する必要がある。

- 破棄されたメッセージは再現してはならない:

  　　新しいトランザクションがLeaderで既に通過し、そのトランザクションが本地に更新された場合でも、すべてのSubscriberがまだCOMMITを受信していない状態でLeader故障した場合、このProposalの存在はSubscriber全体には察知しない。新しいLeaderが選出され、クラスタ全体が正常なサービス状態になった後、以前に故障したLeaderホストが再起動し、Followerとして登録される可能性がある。そのProposalが他のサーバーにまったく知られていない場合、そのホストには不正確なデータが含まれ、システム全体の状態の不整合を引き起こす可能性があります。したがって、そのProposalは破棄されるべきです。このように破棄すべきトランザクションは、クラスタに再び現れるべきではなく、クリアされるべきです。

**ZAB協議核心**

- 全てのトランザクション請求は、全局の唯一のサーバーによって調整されなければならない。このサーバーはLeaderと呼ばれる。残りのサーバーはFollowerサーバー、又はObserverサーバーです。
- Leaderサーバーは、クライアントのトランザクションリク請求をトランザクション提案（Proposal）に変換し、この提案をクラスター内の全てのFollower/Observerサーバーに分配する責任を持つ。つまり、全ての節点にデータの最新の変更内容を送信する。
- 分配後、Leaderサーバーは全てのFollowerからのフィードバック（Ack請求）を待機する。Zab協議では、半数以上のFollowerから正しいAck請求を受信すれば、Leaderは全てのFollowerに対して前回のトランザクション提案をコミットする要求を提出し、再度 Commit メッセージを送信する。

