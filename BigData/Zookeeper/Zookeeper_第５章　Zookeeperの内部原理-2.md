# 分散型協調サービスフレームワーク -- Zookeeper-5

## 第５章　Zookeeperの内部原理-2

### 第２節　ZAB協議

　　ZAB（Zookeeper Atomic Broadcast）は崩壊の回復を支持するの原子放送協議です。別の言い方は、ZooKeeperクラスタ内の各サーバー間のデータ整合性を維持するため設計されたの稼働規則という解釈が理解しやすいと思う。ZAB協議が各サーバー間に稼働の流れを説明でき、主にLeader/Follower主従関係の架構を通じてクラスタ全体の整合性を実現してくる。

#### ZAB協議流れ

![image-20231117100312913](D:\OneDrive\picture\Typora\image-20231117100312913.png)

　　ZAB協議は、各Leaderが3つの段階（発見、同期、放送）を経る必要があり、その前に必ず全局の唯一のLeaderを選出する。

**発見（Discovery）**

　　この段階で選挙流れがまだ終わらない、選出されたの準LeaderはFollowers毎と通信してデータのバージョンを取り集め、欠けのトランザクションを提案（Proposal）として発送する。同時に新しいepoch（今回選挙標識）を生成し、今回選挙情報などと一緒に発送し出す。その主な目的は、次の段階にFollowersが最新トランザクション提案を同期化にするのを準備しておくんです。

**同期（Synchronization）**

　　Leaderは、自身のデータをFollowerに同期させる責任を持ち、Followersについて異なる提案を準備しておく。この段階にFollowersが受信した提案などを同期する。半数以上のFollowersが完了すると、準Leaderが本当のLeaderになる。Followerには自分のlastZxidよりも大きなzxidを持つ提案のみを受け入れる。隊列中に未処理の請求を完了した後、受信の情報を本地のログに書き込む。

**放送（Broadcast）**

　　ここから各サーバーの前期準備が終わり、外部の請求を受信し始める。

![image-20231117103046838](D:\OneDrive\picture\Typora\image-20231117103046838.png)

　　先ず、トランザクション請求（write request）の処理について、どのFollowerでもトランザクション請求を受信したら、請求をLeaderに転送して統一に処理する。Leaderが単一の主プロセスで請求の内容に応じてデータを変更操作を順次行う。Leaderのデータが変更されたと、対応の提案を作成して他のFollowerに分配する。半分以上のFollowerの同期を完成したら今回同期が円滑に完成するんです。その方法で各サーバーが最新の変更内容を保証できてくる。全体の過程でFollowerがLeaderの購読者みたいLeaderから内容を受け取る。

　　次に、普通の読み込み請求（read request）について、請求を受信したサーバーが自身で検査結果を直接返し、Leaderに報告するなど請求が必要ない。

#### ZAB協議内容

　　ZAB協議は基本的に二つの模式が分け：回復模式や放送模式。

**回復模式**

　　クラスタ全体の起動中や、Leaderサーバーが通信の切断、崩潰、再起動などの異常を起こした場合、クラスタが回復模式に入る。具体の内容は、Leaderが選出されたから外部の請求を受信するまでの準備、どのようにデータを同期して各Subscriberが一致性を保証することが解釈してある。

- Leaderは各Subscriberに対して順序を保証するまま提案を送信するために、各subscriberに隊列を用意する。
- Leaderは各Subscriberが同期していないトランザクションをProposalとして包装してくれる。
- LeaderはこれらのProposalを個別にSubscriberに送信し、Ackのフィードバックを受信するとSubscriberにCommitメッセージを発出してProposalをコミットさせる。その時使用可能なSubscriberリストに追加する。ACKがない場合、又はACKが返信されたがLeaderが受信しなかった場合、Leaderはそれを対応するリストに追加しない。
- SubscriberはCommitメッセージを受信し、本地のデータを更新する。

　　クラスが起動中であるか、又はLeaderが半数以上のホストとの接続を失った場合、クラスタは回復模式に入る。データを復旧する過程には2つの原則がある。

- 処理済みのメッセージは失われてはならない:

  　　　　Leaderは半数以上のSubscriberからACKを受信すると、各SubscriberにCommitメッセージを発送し、書き込み操作の実行を承認する。ただし、全SubscriberがCommitメッセージを受信する前にLeaderが故障した場合、結果として次のような問題が発生する：一部のSubscriberはすでにそのトランザクションを実行しており、一部のSubscriberはまだCommitメッセージを受信してない。従って、新しいLeaderが選出されると、クラスタが回復模式を経て部分の実行しないトランザクションがコミット操作を完成することを保証する必要がある。

- 廃棄されたメッセージは再現してはならない:

  　　　　新しいトランザクションがLeaderで既に通過し、そのトランザクションが本地に更新された場合でも、SubscriberがまだCommitを受信していない状態でLeader故障した場合、このProposalの存在はSubscriber全体には察知しない。新しいLeaderが選出されてクラスタ全体が正常なサービス状態になった後、以前に故障したLeaderホストが再起動してFollowerとして登録される。その時、正常に運行する下にFollowerがLeaderになるわけない。勿論、全体のZookeeperサービス再起動すれば、大きなトランザクションIDによってLeaderの権限を取り返す可能性がある。ただ、一旦現行サービスが新しいトランザクション請求を受けたら、上記の結果が出現しない、以前の更新情報が徹底的に回復の可能性がない。従って、そのProposalは廃棄されしてあり、クラスタに再び現れるべきではなく、全て消除してくれる。一言で小さなzxid（トランザクションID）が大きなzxidに対応のProposalを書き込んでいけないという規則である。

**放送模式**

　　クラスタ内のLearnerが初期化された状態同期を完了すると、Zookeeperクラスタ全体が通常の動作模式に入る。核心の部分はLearnerの更新したデータをSubscriberに分配して一致性を保証することです。模式が異なるんですが、両者も同期の流れに属し、実際の内容が同じです。ここは次のZAB協議核心に詳しく説明してあげる。

#### ZAB協議核心

　　クラスタ内のSubscriberがトランザクション請求を受信した場合、Leaderに消息を転送する。下記の手順に従って各Subscriberにデータを同期すると完成する。

1. Leaderはトランザクションにグローバルで一意な64ビットの自動増分IDであるzxidを割り当てます。zxidのサイズ比較により、トランザクションの順序管理が可能です。その後、LeaderはトランザクションをProposalとして封装します。
2. LeaderはFollowerリストを使用してすべてのFollowerを取得し、次にこれらのFollowerのキューを介してProposalを送信します。
3. Followerは提案を受信すると、まず提案のzxidをローカルに記録された事务ログの最大zxidと比較します。現在の提案のzxidが最大のzxidよりも大きい場合、Followerは現在の提案をローカルの事务ログに記録し、LeaderにACKを返します。
4. Leaderは半数以上のACKを受信すると、すべてのFollowerのキューにCOMMITメッセージを送信し、すべてのObserverのキューにProposalを送信します。
5. FollowerはCOMMITメッセージを受信すると、トランザクションを正式にローカルに更新します。ObserverはProposalを受信すると、トランザクションを直接ローカルに更新します。
6. FollowerまたはObserverは同期が完了すると、Leaderに成功のACKを送信する必要があります。
